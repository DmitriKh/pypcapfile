{"body":"Installing\r\n----------\r\n\r\nThe easiest way to install is from \r\n[pypi](http://pypi.python.org/pypi/pypcapfile/):\r\n\r\n```bash\r\nsudo pip install pypcapfile\r\n```\r\n\r\nNote that for pip, the package name is `pypcapfile`; in your code you will need to \r\nimport `pcapfile`.\r\n\r\nAlternatively, you can install from source. Clone the repository, and run setup.py with \r\nan install argument:\r\n\r\n```bash\r\ngit clone git://github.com/kisom/pypcapfile.git\r\ncd pypcapfile\r\n./setup.py install\r\n```\r\n\r\nThis does require the Python [distutils](http://docs.python.org/install/) to be\r\ninstalled.\r\n\r\n\r\nIntroduction\r\n------------\r\n\r\nThe core functionality is implemented in `pcapfile.savefile`:\r\n\r\n```python\r\n>>> from pcapfile import savefile\r\n>>> testcap = open('test.pcap')\r\n>>> capfile = savefile.load_savefile(testcap, verbose=True)\r\n[+] attempting to load test.pcap\r\n[+] found valid header\r\n[+] loaded 11 packets\r\n[+] finished loading savefile.\r\n>>> print capfile\r\nlittle-endian capture file version 2.4\r\nsnapshot length: 65535\r\nlinklayer type: LINKTYPE_ETHERNET\r\nnumber of packets: 11\r\n```\r\n\r\nYou can take a look at the packets in `capfile.packets`:\r\n```python\r\n>>> pkt = capfile.packets[0]\r\n>>> pkt.raw()\r\n<binary data snipped>\r\n>>> pkt.timestamp\r\n1343676707L\r\n```\r\n\r\nRight now there is very basic support for Ethernet frames and IPv4 packet \r\nparsing. \r\n\r\nAutomatically decoding layers\r\n-----------------------------\r\n\r\nThe `layers` argument to `load_savefile` determines how many layers to \r\ndecode; the default value of 0 does no decoding, 1 will load only the link \r\nlayer, etc... For example, with no decoding:\r\n\r\n```python\r\n>>> from pcapfile import savefile\r\n>>> from pcapfile.protocols.linklayer import ethernet\r\n>>> from pcapfile.protocols.network import ip\r\n>>> import binascii\r\n>>> testcap = open('samples/test.pcap')\r\n>>> capfile = savefile.load_savefile(testcap, verbose=True)\r\n[+] attempting to load samples/test.pcap\r\n[+] found valid header\r\n[+] loaded 3 packets\r\n[+] finished loading savefile.\r\n>>> eth_frame = ethernet.Ethernet(capfile.packets[0].raw())\r\n>>> print eth_frame\r\nethernet from 00:11:22:33:44:55 to ff:ee:dd:cc:bb:aa type IPv4\r\n>>> ip_packet = ip.IP(binascii.unhexlify(eth_frame.payload))\r\n>>> print ip_packet\r\nipv4 packet from 192.168.2.47 to 173.194.37.82 carrying 44 bytes\r\n```\r\n\r\nand this example:\r\n\r\n```python\r\n>>> from pcapfile import savefile\r\n>>> testcap = open('samples/test.pcap')\r\n>>> capfile = savefile.load_savefile(testcap, layers=1, verbose=True)\r\n[+] attempting to load samples/test.pcap\r\n[+] found valid header\r\n[+] loaded 3 packets\r\n[+] finished loading savefile.\r\n>>> print capfile.packets[0].packet.src\r\n00:11:22:33:44:55\r\n>>> print capfile.packets[0].packet.payload\r\n<hex string snipped>\r\n```\r\n\r\nand lastly:\r\n```python\r\n>>> from pcapfile import savefile\r\n>>> testcap = open('samples/test.pcap')\r\n>>> capfile = savefile.load_savefile(testcap, layers=2, verbose=True)\r\n>>> print capfile.packets[0].packet.payload\r\nipv4 packet from 192.168.2.47 to 173.194.37.82 carrying 44 bytes\r\n```\r\n\r\nThe IPv4 module (`ip`) currently only supports basic IP headers, i.e. it \r\ndoesn't yet parse options or add in padding.\r\n\r\nThe interface is still a bit messy.\r\n\r\n\r\nFuture planned improvements\r\n---------------------------\r\n\r\n* IP option handling\r\n* IPv6 support\r\n* TCP and UDP support\r\n* ARP support\r\n\r\n\r\nTODO\r\n----\r\n\r\n0. write unit tests\r\n0. add `__repr__` method that shows all of the values of the fields in IP packets\r\nand Ethernet frames.\r\n\r\n\r\nSee also\r\n--------\r\n\r\n* The project's [PyPi page](http://pypi.python.org/pypi/pypcapfile).\r\n* The project's [Sphinx](http://sphinx.pocoo.org/) \r\n[documentation on PyPI](http://packages.python.org/pypcapfile/)\r\n* The [libpcap homepage](http://www.tcpdump.org)\r\n\r\nContributors\r\n------------\r\npycapfile was written by [Kyle Isom](https://github.com/kisom/).\r\n\r\n[Joshua Chia](https://github.com/jchia/) provided a patch to use the standard\r\nPython file objects instead of a path to the file; this allows transparent\r\nhandling of certain types of compressed files.\r\n","google":"","tagline":"Pure Python library for handling libpcap savefiles.","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Pypcapfile"}